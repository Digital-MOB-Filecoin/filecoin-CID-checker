// Code generated by mockery v0.0.0-dev. DO NOT EDIT.

package mocks

import (
	address "github.com/filecoin-project/go-address"
	abi "github.com/filecoin-project/specs-actors/actors/abi"

	api "github.com/filecoin-project/lotus/api"

	auth "github.com/filecoin-project/go-jsonrpc/auth"

	big "github.com/filecoin-project/specs-actors/actors/abi/big"

	bitfield "github.com/filecoin-project/go-bitfield"

	cid "github.com/ipfs/go-cid"

	context "context"

	crypto "github.com/filecoin-project/specs-actors/actors/crypto"

	dtypes "github.com/filecoin-project/lotus/node/modules/dtypes"

	miner "github.com/filecoin-project/specs-actors/actors/builtin/miner"

	mock "github.com/stretchr/testify/mock"

	network "github.com/libp2p/go-libp2p-core/network"

	paych "github.com/filecoin-project/specs-actors/actors/builtin/paych"

	peer "github.com/libp2p/go-libp2p-core/peer"

	storagemarket "github.com/filecoin-project/go-fil-markets/storagemarket"

	types "github.com/filecoin-project/lotus/chain/types"
)

// FullNode is an autogenerated mock type for the FullNode type
type FullNode struct {
	mock.Mock
}

// AuthNew provides a mock function with given fields: ctx, perms
func (_m *FullNode) AuthNew(ctx context.Context, perms []auth.Permission) ([]byte, error) {
	ret := _m.Called(ctx, perms)

	var r0 []byte
	if rf, ok := ret.Get(0).(func(context.Context, []auth.Permission) []byte); ok {
		r0 = rf(ctx, perms)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, []auth.Permission) error); ok {
		r1 = rf(ctx, perms)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AuthVerify provides a mock function with given fields: ctx, token
func (_m *FullNode) AuthVerify(ctx context.Context, token string) ([]auth.Permission, error) {
	ret := _m.Called(ctx, token)

	var r0 []auth.Permission
	if rf, ok := ret.Get(0).(func(context.Context, string) []auth.Permission); ok {
		r0 = rf(ctx, token)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]auth.Permission)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, token)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ChainExport provides a mock function with given fields: _a0, _a1
func (_m *FullNode) ChainExport(_a0 context.Context, _a1 types.TipSetKey) (<-chan []byte, error) {
	ret := _m.Called(_a0, _a1)

	var r0 <-chan []byte
	if rf, ok := ret.Get(0).(func(context.Context, types.TipSetKey) <-chan []byte); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(<-chan []byte)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, types.TipSetKey) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ChainGetBlock provides a mock function with given fields: _a0, _a1
func (_m *FullNode) ChainGetBlock(_a0 context.Context, _a1 cid.Cid) (*types.BlockHeader, error) {
	ret := _m.Called(_a0, _a1)

	var r0 *types.BlockHeader
	if rf, ok := ret.Get(0).(func(context.Context, cid.Cid) *types.BlockHeader); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.BlockHeader)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, cid.Cid) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ChainGetBlockMessages provides a mock function with given fields: ctx, blockCid
func (_m *FullNode) ChainGetBlockMessages(ctx context.Context, blockCid cid.Cid) (*api.BlockMessages, error) {
	ret := _m.Called(ctx, blockCid)

	var r0 *api.BlockMessages
	if rf, ok := ret.Get(0).(func(context.Context, cid.Cid) *api.BlockMessages); ok {
		r0 = rf(ctx, blockCid)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.BlockMessages)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, cid.Cid) error); ok {
		r1 = rf(ctx, blockCid)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ChainGetGenesis provides a mock function with given fields: _a0
func (_m *FullNode) ChainGetGenesis(_a0 context.Context) (*types.TipSet, error) {
	ret := _m.Called(_a0)

	var r0 *types.TipSet
	if rf, ok := ret.Get(0).(func(context.Context) *types.TipSet); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.TipSet)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ChainGetMessage provides a mock function with given fields: _a0, _a1
func (_m *FullNode) ChainGetMessage(_a0 context.Context, _a1 cid.Cid) (*types.Message, error) {
	ret := _m.Called(_a0, _a1)

	var r0 *types.Message
	if rf, ok := ret.Get(0).(func(context.Context, cid.Cid) *types.Message); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Message)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, cid.Cid) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ChainGetNode provides a mock function with given fields: ctx, p
func (_m *FullNode) ChainGetNode(ctx context.Context, p string) (*api.IpldObject, error) {
	ret := _m.Called(ctx, p)

	var r0 *api.IpldObject
	if rf, ok := ret.Get(0).(func(context.Context, string) *api.IpldObject); ok {
		r0 = rf(ctx, p)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.IpldObject)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, p)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ChainGetParentMessages provides a mock function with given fields: ctx, blockCid
func (_m *FullNode) ChainGetParentMessages(ctx context.Context, blockCid cid.Cid) ([]api.Message, error) {
	ret := _m.Called(ctx, blockCid)

	var r0 []api.Message
	if rf, ok := ret.Get(0).(func(context.Context, cid.Cid) []api.Message); ok {
		r0 = rf(ctx, blockCid)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]api.Message)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, cid.Cid) error); ok {
		r1 = rf(ctx, blockCid)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ChainGetParentReceipts provides a mock function with given fields: ctx, blockCid
func (_m *FullNode) ChainGetParentReceipts(ctx context.Context, blockCid cid.Cid) ([]*types.MessageReceipt, error) {
	ret := _m.Called(ctx, blockCid)

	var r0 []*types.MessageReceipt
	if rf, ok := ret.Get(0).(func(context.Context, cid.Cid) []*types.MessageReceipt); ok {
		r0 = rf(ctx, blockCid)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*types.MessageReceipt)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, cid.Cid) error); ok {
		r1 = rf(ctx, blockCid)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ChainGetPath provides a mock function with given fields: ctx, from, to
func (_m *FullNode) ChainGetPath(ctx context.Context, from types.TipSetKey, to types.TipSetKey) ([]*api.HeadChange, error) {
	ret := _m.Called(ctx, from, to)

	var r0 []*api.HeadChange
	if rf, ok := ret.Get(0).(func(context.Context, types.TipSetKey, types.TipSetKey) []*api.HeadChange); ok {
		r0 = rf(ctx, from, to)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*api.HeadChange)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, types.TipSetKey, types.TipSetKey) error); ok {
		r1 = rf(ctx, from, to)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ChainGetRandomness provides a mock function with given fields: ctx, tsk, personalization, randEpoch, entropy
func (_m *FullNode) ChainGetRandomness(ctx context.Context, tsk types.TipSetKey, personalization crypto.DomainSeparationTag, randEpoch abi.ChainEpoch, entropy []byte) (abi.Randomness, error) {
	ret := _m.Called(ctx, tsk, personalization, randEpoch, entropy)

	var r0 abi.Randomness
	if rf, ok := ret.Get(0).(func(context.Context, types.TipSetKey, crypto.DomainSeparationTag, abi.ChainEpoch, []byte) abi.Randomness); ok {
		r0 = rf(ctx, tsk, personalization, randEpoch, entropy)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(abi.Randomness)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, types.TipSetKey, crypto.DomainSeparationTag, abi.ChainEpoch, []byte) error); ok {
		r1 = rf(ctx, tsk, personalization, randEpoch, entropy)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ChainGetTipSet provides a mock function with given fields: _a0, _a1
func (_m *FullNode) ChainGetTipSet(_a0 context.Context, _a1 types.TipSetKey) (*types.TipSet, error) {
	ret := _m.Called(_a0, _a1)

	var r0 *types.TipSet
	if rf, ok := ret.Get(0).(func(context.Context, types.TipSetKey) *types.TipSet); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.TipSet)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, types.TipSetKey) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ChainGetTipSetByHeight provides a mock function with given fields: _a0, _a1, _a2
func (_m *FullNode) ChainGetTipSetByHeight(_a0 context.Context, _a1 abi.ChainEpoch, _a2 types.TipSetKey) (*types.TipSet, error) {
	ret := _m.Called(_a0, _a1, _a2)

	var r0 *types.TipSet
	if rf, ok := ret.Get(0).(func(context.Context, abi.ChainEpoch, types.TipSetKey) *types.TipSet); ok {
		r0 = rf(_a0, _a1, _a2)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.TipSet)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, abi.ChainEpoch, types.TipSetKey) error); ok {
		r1 = rf(_a0, _a1, _a2)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ChainHasObj provides a mock function with given fields: _a0, _a1
func (_m *FullNode) ChainHasObj(_a0 context.Context, _a1 cid.Cid) (bool, error) {
	ret := _m.Called(_a0, _a1)

	var r0 bool
	if rf, ok := ret.Get(0).(func(context.Context, cid.Cid) bool); ok {
		r0 = rf(_a0, _a1)
	} else {
		r0 = ret.Get(0).(bool)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, cid.Cid) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ChainHead provides a mock function with given fields: _a0
func (_m *FullNode) ChainHead(_a0 context.Context) (*types.TipSet, error) {
	ret := _m.Called(_a0)

	var r0 *types.TipSet
	if rf, ok := ret.Get(0).(func(context.Context) *types.TipSet); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.TipSet)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ChainNotify provides a mock function with given fields: _a0
func (_m *FullNode) ChainNotify(_a0 context.Context) (<-chan []*api.HeadChange, error) {
	ret := _m.Called(_a0)

	var r0 <-chan []*api.HeadChange
	if rf, ok := ret.Get(0).(func(context.Context) <-chan []*api.HeadChange); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(<-chan []*api.HeadChange)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ChainReadObj provides a mock function with given fields: _a0, _a1
func (_m *FullNode) ChainReadObj(_a0 context.Context, _a1 cid.Cid) ([]byte, error) {
	ret := _m.Called(_a0, _a1)

	var r0 []byte
	if rf, ok := ret.Get(0).(func(context.Context, cid.Cid) []byte); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, cid.Cid) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ChainSetHead provides a mock function with given fields: _a0, _a1
func (_m *FullNode) ChainSetHead(_a0 context.Context, _a1 types.TipSetKey) error {
	ret := _m.Called(_a0, _a1)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, types.TipSetKey) error); ok {
		r0 = rf(_a0, _a1)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ChainStatObj provides a mock function with given fields: _a0, _a1, _a2
func (_m *FullNode) ChainStatObj(_a0 context.Context, _a1 cid.Cid, _a2 cid.Cid) (api.ObjStat, error) {
	ret := _m.Called(_a0, _a1, _a2)

	var r0 api.ObjStat
	if rf, ok := ret.Get(0).(func(context.Context, cid.Cid, cid.Cid) api.ObjStat); ok {
		r0 = rf(_a0, _a1, _a2)
	} else {
		r0 = ret.Get(0).(api.ObjStat)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, cid.Cid, cid.Cid) error); ok {
		r1 = rf(_a0, _a1, _a2)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ChainTipSetWeight provides a mock function with given fields: _a0, _a1
func (_m *FullNode) ChainTipSetWeight(_a0 context.Context, _a1 types.TipSetKey) (big.Int, error) {
	ret := _m.Called(_a0, _a1)

	var r0 big.Int
	if rf, ok := ret.Get(0).(func(context.Context, types.TipSetKey) big.Int); ok {
		r0 = rf(_a0, _a1)
	} else {
		r0 = ret.Get(0).(big.Int)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, types.TipSetKey) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientCalcCommP provides a mock function with given fields: ctx, inpath, _a2
func (_m *FullNode) ClientCalcCommP(ctx context.Context, inpath string, _a2 address.Address) (*api.CommPRet, error) {
	ret := _m.Called(ctx, inpath, _a2)

	var r0 *api.CommPRet
	if rf, ok := ret.Get(0).(func(context.Context, string, address.Address) *api.CommPRet); ok {
		r0 = rf(ctx, inpath, _a2)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.CommPRet)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, address.Address) error); ok {
		r1 = rf(ctx, inpath, _a2)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientFindData provides a mock function with given fields: ctx, root
func (_m *FullNode) ClientFindData(ctx context.Context, root cid.Cid) ([]api.QueryOffer, error) {
	ret := _m.Called(ctx, root)

	var r0 []api.QueryOffer
	if rf, ok := ret.Get(0).(func(context.Context, cid.Cid) []api.QueryOffer); ok {
		r0 = rf(ctx, root)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]api.QueryOffer)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, cid.Cid) error); ok {
		r1 = rf(ctx, root)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientGenCar provides a mock function with given fields: ctx, ref, outpath
func (_m *FullNode) ClientGenCar(ctx context.Context, ref api.FileRef, outpath string) error {
	ret := _m.Called(ctx, ref, outpath)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, api.FileRef, string) error); ok {
		r0 = rf(ctx, ref, outpath)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ClientGetDealInfo provides a mock function with given fields: _a0, _a1
func (_m *FullNode) ClientGetDealInfo(_a0 context.Context, _a1 cid.Cid) (*api.DealInfo, error) {
	ret := _m.Called(_a0, _a1)

	var r0 *api.DealInfo
	if rf, ok := ret.Get(0).(func(context.Context, cid.Cid) *api.DealInfo); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.DealInfo)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, cid.Cid) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientHasLocal provides a mock function with given fields: ctx, root
func (_m *FullNode) ClientHasLocal(ctx context.Context, root cid.Cid) (bool, error) {
	ret := _m.Called(ctx, root)

	var r0 bool
	if rf, ok := ret.Get(0).(func(context.Context, cid.Cid) bool); ok {
		r0 = rf(ctx, root)
	} else {
		r0 = ret.Get(0).(bool)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, cid.Cid) error); ok {
		r1 = rf(ctx, root)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientImport provides a mock function with given fields: ctx, ref
func (_m *FullNode) ClientImport(ctx context.Context, ref api.FileRef) (cid.Cid, error) {
	ret := _m.Called(ctx, ref)

	var r0 cid.Cid
	if rf, ok := ret.Get(0).(func(context.Context, api.FileRef) cid.Cid); ok {
		r0 = rf(ctx, ref)
	} else {
		r0 = ret.Get(0).(cid.Cid)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, api.FileRef) error); ok {
		r1 = rf(ctx, ref)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientListDeals provides a mock function with given fields: ctx
func (_m *FullNode) ClientListDeals(ctx context.Context) ([]api.DealInfo, error) {
	ret := _m.Called(ctx)

	var r0 []api.DealInfo
	if rf, ok := ret.Get(0).(func(context.Context) []api.DealInfo); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]api.DealInfo)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientListImports provides a mock function with given fields: ctx
func (_m *FullNode) ClientListImports(ctx context.Context) ([]api.Import, error) {
	ret := _m.Called(ctx)

	var r0 []api.Import
	if rf, ok := ret.Get(0).(func(context.Context) []api.Import); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]api.Import)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientMinerQueryOffer provides a mock function with given fields: ctx, root, _a2
func (_m *FullNode) ClientMinerQueryOffer(ctx context.Context, root cid.Cid, _a2 address.Address) (api.QueryOffer, error) {
	ret := _m.Called(ctx, root, _a2)

	var r0 api.QueryOffer
	if rf, ok := ret.Get(0).(func(context.Context, cid.Cid, address.Address) api.QueryOffer); ok {
		r0 = rf(ctx, root, _a2)
	} else {
		r0 = ret.Get(0).(api.QueryOffer)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, cid.Cid, address.Address) error); ok {
		r1 = rf(ctx, root, _a2)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientQueryAsk provides a mock function with given fields: ctx, p, _a2
func (_m *FullNode) ClientQueryAsk(ctx context.Context, p peer.ID, _a2 address.Address) (*storagemarket.SignedStorageAsk, error) {
	ret := _m.Called(ctx, p, _a2)

	var r0 *storagemarket.SignedStorageAsk
	if rf, ok := ret.Get(0).(func(context.Context, peer.ID, address.Address) *storagemarket.SignedStorageAsk); ok {
		r0 = rf(ctx, p, _a2)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*storagemarket.SignedStorageAsk)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, peer.ID, address.Address) error); ok {
		r1 = rf(ctx, p, _a2)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClientRetrieve provides a mock function with given fields: ctx, order, ref
func (_m *FullNode) ClientRetrieve(ctx context.Context, order api.RetrievalOrder, ref *api.FileRef) error {
	ret := _m.Called(ctx, order, ref)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, api.RetrievalOrder, *api.FileRef) error); ok {
		r0 = rf(ctx, order, ref)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ClientStartDeal provides a mock function with given fields: ctx, params
func (_m *FullNode) ClientStartDeal(ctx context.Context, params *api.StartDealParams) (*cid.Cid, error) {
	ret := _m.Called(ctx, params)

	var r0 *cid.Cid
	if rf, ok := ret.Get(0).(func(context.Context, *api.StartDealParams) *cid.Cid); ok {
		r0 = rf(ctx, params)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*cid.Cid)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *api.StartDealParams) error); ok {
		r1 = rf(ctx, params)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Closing provides a mock function with given fields: _a0
func (_m *FullNode) Closing(_a0 context.Context) (<-chan struct{}, error) {
	ret := _m.Called(_a0)

	var r0 <-chan struct{}
	if rf, ok := ret.Get(0).(func(context.Context) <-chan struct{}); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(<-chan struct{})
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ID provides a mock function with given fields: _a0
func (_m *FullNode) ID(_a0 context.Context) (peer.ID, error) {
	ret := _m.Called(_a0)

	var r0 peer.ID
	if rf, ok := ret.Get(0).(func(context.Context) peer.ID); ok {
		r0 = rf(_a0)
	} else {
		r0 = ret.Get(0).(peer.ID)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// LogList provides a mock function with given fields: _a0
func (_m *FullNode) LogList(_a0 context.Context) ([]string, error) {
	ret := _m.Called(_a0)

	var r0 []string
	if rf, ok := ret.Get(0).(func(context.Context) []string); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// LogSetLevel provides a mock function with given fields: _a0, _a1, _a2
func (_m *FullNode) LogSetLevel(_a0 context.Context, _a1 string, _a2 string) error {
	ret := _m.Called(_a0, _a1, _a2)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) error); ok {
		r0 = rf(_a0, _a1, _a2)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MarketEnsureAvailable provides a mock function with given fields: _a0, _a1, _a2, _a3
func (_m *FullNode) MarketEnsureAvailable(_a0 context.Context, _a1 address.Address, _a2 address.Address, _a3 big.Int) (cid.Cid, error) {
	ret := _m.Called(_a0, _a1, _a2, _a3)

	var r0 cid.Cid
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, address.Address, big.Int) cid.Cid); ok {
		r0 = rf(_a0, _a1, _a2, _a3)
	} else {
		r0 = ret.Get(0).(cid.Cid)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, address.Address, address.Address, big.Int) error); ok {
		r1 = rf(_a0, _a1, _a2, _a3)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MinerCreateBlock provides a mock function with given fields: _a0, _a1
func (_m *FullNode) MinerCreateBlock(_a0 context.Context, _a1 *api.BlockTemplate) (*types.BlockMsg, error) {
	ret := _m.Called(_a0, _a1)

	var r0 *types.BlockMsg
	if rf, ok := ret.Get(0).(func(context.Context, *api.BlockTemplate) *types.BlockMsg); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.BlockMsg)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *api.BlockTemplate) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MinerGetBaseInfo provides a mock function with given fields: _a0, _a1, _a2, _a3
func (_m *FullNode) MinerGetBaseInfo(_a0 context.Context, _a1 address.Address, _a2 abi.ChainEpoch, _a3 types.TipSetKey) (*api.MiningBaseInfo, error) {
	ret := _m.Called(_a0, _a1, _a2, _a3)

	var r0 *api.MiningBaseInfo
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, abi.ChainEpoch, types.TipSetKey) *api.MiningBaseInfo); ok {
		r0 = rf(_a0, _a1, _a2, _a3)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.MiningBaseInfo)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, address.Address, abi.ChainEpoch, types.TipSetKey) error); ok {
		r1 = rf(_a0, _a1, _a2, _a3)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MpoolEstimateGasPrice provides a mock function with given fields: ctx, nblocksincl, sender, gaslimit, tsk
func (_m *FullNode) MpoolEstimateGasPrice(ctx context.Context, nblocksincl uint64, sender address.Address, gaslimit int64, tsk types.TipSetKey) (big.Int, error) {
	ret := _m.Called(ctx, nblocksincl, sender, gaslimit, tsk)

	var r0 big.Int
	if rf, ok := ret.Get(0).(func(context.Context, uint64, address.Address, int64, types.TipSetKey) big.Int); ok {
		r0 = rf(ctx, nblocksincl, sender, gaslimit, tsk)
	} else {
		r0 = ret.Get(0).(big.Int)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, uint64, address.Address, int64, types.TipSetKey) error); ok {
		r1 = rf(ctx, nblocksincl, sender, gaslimit, tsk)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MpoolGetNonce provides a mock function with given fields: _a0, _a1
func (_m *FullNode) MpoolGetNonce(_a0 context.Context, _a1 address.Address) (uint64, error) {
	ret := _m.Called(_a0, _a1)

	var r0 uint64
	if rf, ok := ret.Get(0).(func(context.Context, address.Address) uint64); ok {
		r0 = rf(_a0, _a1)
	} else {
		r0 = ret.Get(0).(uint64)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, address.Address) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MpoolPending provides a mock function with given fields: _a0, _a1
func (_m *FullNode) MpoolPending(_a0 context.Context, _a1 types.TipSetKey) ([]*types.SignedMessage, error) {
	ret := _m.Called(_a0, _a1)

	var r0 []*types.SignedMessage
	if rf, ok := ret.Get(0).(func(context.Context, types.TipSetKey) []*types.SignedMessage); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*types.SignedMessage)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, types.TipSetKey) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MpoolPush provides a mock function with given fields: _a0, _a1
func (_m *FullNode) MpoolPush(_a0 context.Context, _a1 *types.SignedMessage) (cid.Cid, error) {
	ret := _m.Called(_a0, _a1)

	var r0 cid.Cid
	if rf, ok := ret.Get(0).(func(context.Context, *types.SignedMessage) cid.Cid); ok {
		r0 = rf(_a0, _a1)
	} else {
		r0 = ret.Get(0).(cid.Cid)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *types.SignedMessage) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MpoolPushMessage provides a mock function with given fields: _a0, _a1
func (_m *FullNode) MpoolPushMessage(_a0 context.Context, _a1 *types.Message) (*types.SignedMessage, error) {
	ret := _m.Called(_a0, _a1)

	var r0 *types.SignedMessage
	if rf, ok := ret.Get(0).(func(context.Context, *types.Message) *types.SignedMessage); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.SignedMessage)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *types.Message) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MpoolSub provides a mock function with given fields: _a0
func (_m *FullNode) MpoolSub(_a0 context.Context) (<-chan api.MpoolUpdate, error) {
	ret := _m.Called(_a0)

	var r0 <-chan api.MpoolUpdate
	if rf, ok := ret.Get(0).(func(context.Context) <-chan api.MpoolUpdate); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(<-chan api.MpoolUpdate)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MsigApprove provides a mock function with given fields: _a0, _a1, _a2, _a3, _a4, _a5, _a6, _a7, _a8
func (_m *FullNode) MsigApprove(_a0 context.Context, _a1 address.Address, _a2 uint64, _a3 address.Address, _a4 address.Address, _a5 big.Int, _a6 address.Address, _a7 uint64, _a8 []byte) (cid.Cid, error) {
	ret := _m.Called(_a0, _a1, _a2, _a3, _a4, _a5, _a6, _a7, _a8)

	var r0 cid.Cid
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, uint64, address.Address, address.Address, big.Int, address.Address, uint64, []byte) cid.Cid); ok {
		r0 = rf(_a0, _a1, _a2, _a3, _a4, _a5, _a6, _a7, _a8)
	} else {
		r0 = ret.Get(0).(cid.Cid)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, address.Address, uint64, address.Address, address.Address, big.Int, address.Address, uint64, []byte) error); ok {
		r1 = rf(_a0, _a1, _a2, _a3, _a4, _a5, _a6, _a7, _a8)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MsigCancel provides a mock function with given fields: _a0, _a1, _a2, _a3, _a4, _a5, _a6, _a7, _a8
func (_m *FullNode) MsigCancel(_a0 context.Context, _a1 address.Address, _a2 uint64, _a3 address.Address, _a4 address.Address, _a5 big.Int, _a6 address.Address, _a7 uint64, _a8 []byte) (cid.Cid, error) {
	ret := _m.Called(_a0, _a1, _a2, _a3, _a4, _a5, _a6, _a7, _a8)

	var r0 cid.Cid
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, uint64, address.Address, address.Address, big.Int, address.Address, uint64, []byte) cid.Cid); ok {
		r0 = rf(_a0, _a1, _a2, _a3, _a4, _a5, _a6, _a7, _a8)
	} else {
		r0 = ret.Get(0).(cid.Cid)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, address.Address, uint64, address.Address, address.Address, big.Int, address.Address, uint64, []byte) error); ok {
		r1 = rf(_a0, _a1, _a2, _a3, _a4, _a5, _a6, _a7, _a8)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MsigCreate provides a mock function with given fields: _a0, _a1, _a2, _a3, _a4, _a5
func (_m *FullNode) MsigCreate(_a0 context.Context, _a1 int64, _a2 []address.Address, _a3 big.Int, _a4 address.Address, _a5 big.Int) (cid.Cid, error) {
	ret := _m.Called(_a0, _a1, _a2, _a3, _a4, _a5)

	var r0 cid.Cid
	if rf, ok := ret.Get(0).(func(context.Context, int64, []address.Address, big.Int, address.Address, big.Int) cid.Cid); ok {
		r0 = rf(_a0, _a1, _a2, _a3, _a4, _a5)
	} else {
		r0 = ret.Get(0).(cid.Cid)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, int64, []address.Address, big.Int, address.Address, big.Int) error); ok {
		r1 = rf(_a0, _a1, _a2, _a3, _a4, _a5)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MsigGetAvailableBalance provides a mock function with given fields: _a0, _a1, _a2
func (_m *FullNode) MsigGetAvailableBalance(_a0 context.Context, _a1 address.Address, _a2 types.TipSetKey) (big.Int, error) {
	ret := _m.Called(_a0, _a1, _a2)

	var r0 big.Int
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, types.TipSetKey) big.Int); ok {
		r0 = rf(_a0, _a1, _a2)
	} else {
		r0 = ret.Get(0).(big.Int)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, address.Address, types.TipSetKey) error); ok {
		r1 = rf(_a0, _a1, _a2)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MsigPropose provides a mock function with given fields: _a0, _a1, _a2, _a3, _a4, _a5, _a6
func (_m *FullNode) MsigPropose(_a0 context.Context, _a1 address.Address, _a2 address.Address, _a3 big.Int, _a4 address.Address, _a5 uint64, _a6 []byte) (cid.Cid, error) {
	ret := _m.Called(_a0, _a1, _a2, _a3, _a4, _a5, _a6)

	var r0 cid.Cid
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, address.Address, big.Int, address.Address, uint64, []byte) cid.Cid); ok {
		r0 = rf(_a0, _a1, _a2, _a3, _a4, _a5, _a6)
	} else {
		r0 = ret.Get(0).(cid.Cid)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, address.Address, address.Address, big.Int, address.Address, uint64, []byte) error); ok {
		r1 = rf(_a0, _a1, _a2, _a3, _a4, _a5, _a6)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NetAddrsListen provides a mock function with given fields: _a0
func (_m *FullNode) NetAddrsListen(_a0 context.Context) (peer.AddrInfo, error) {
	ret := _m.Called(_a0)

	var r0 peer.AddrInfo
	if rf, ok := ret.Get(0).(func(context.Context) peer.AddrInfo); ok {
		r0 = rf(_a0)
	} else {
		r0 = ret.Get(0).(peer.AddrInfo)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NetConnect provides a mock function with given fields: _a0, _a1
func (_m *FullNode) NetConnect(_a0 context.Context, _a1 peer.AddrInfo) error {
	ret := _m.Called(_a0, _a1)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, peer.AddrInfo) error); ok {
		r0 = rf(_a0, _a1)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// NetConnectedness provides a mock function with given fields: _a0, _a1
func (_m *FullNode) NetConnectedness(_a0 context.Context, _a1 peer.ID) (network.Connectedness, error) {
	ret := _m.Called(_a0, _a1)

	var r0 network.Connectedness
	if rf, ok := ret.Get(0).(func(context.Context, peer.ID) network.Connectedness); ok {
		r0 = rf(_a0, _a1)
	} else {
		r0 = ret.Get(0).(network.Connectedness)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, peer.ID) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NetDisconnect provides a mock function with given fields: _a0, _a1
func (_m *FullNode) NetDisconnect(_a0 context.Context, _a1 peer.ID) error {
	ret := _m.Called(_a0, _a1)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, peer.ID) error); ok {
		r0 = rf(_a0, _a1)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// NetFindPeer provides a mock function with given fields: _a0, _a1
func (_m *FullNode) NetFindPeer(_a0 context.Context, _a1 peer.ID) (peer.AddrInfo, error) {
	ret := _m.Called(_a0, _a1)

	var r0 peer.AddrInfo
	if rf, ok := ret.Get(0).(func(context.Context, peer.ID) peer.AddrInfo); ok {
		r0 = rf(_a0, _a1)
	} else {
		r0 = ret.Get(0).(peer.AddrInfo)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, peer.ID) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NetPeers provides a mock function with given fields: _a0
func (_m *FullNode) NetPeers(_a0 context.Context) ([]peer.AddrInfo, error) {
	ret := _m.Called(_a0)

	var r0 []peer.AddrInfo
	if rf, ok := ret.Get(0).(func(context.Context) []peer.AddrInfo); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]peer.AddrInfo)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NetPubsubScores provides a mock function with given fields: _a0
func (_m *FullNode) NetPubsubScores(_a0 context.Context) ([]api.PubsubScore, error) {
	ret := _m.Called(_a0)

	var r0 []api.PubsubScore
	if rf, ok := ret.Get(0).(func(context.Context) []api.PubsubScore); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]api.PubsubScore)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PaychAllocateLane provides a mock function with given fields: ctx, ch
func (_m *FullNode) PaychAllocateLane(ctx context.Context, ch address.Address) (uint64, error) {
	ret := _m.Called(ctx, ch)

	var r0 uint64
	if rf, ok := ret.Get(0).(func(context.Context, address.Address) uint64); ok {
		r0 = rf(ctx, ch)
	} else {
		r0 = ret.Get(0).(uint64)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, address.Address) error); ok {
		r1 = rf(ctx, ch)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PaychClose provides a mock function with given fields: _a0, _a1
func (_m *FullNode) PaychClose(_a0 context.Context, _a1 address.Address) (cid.Cid, error) {
	ret := _m.Called(_a0, _a1)

	var r0 cid.Cid
	if rf, ok := ret.Get(0).(func(context.Context, address.Address) cid.Cid); ok {
		r0 = rf(_a0, _a1)
	} else {
		r0 = ret.Get(0).(cid.Cid)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, address.Address) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PaychGet provides a mock function with given fields: ctx, from, to, ensureFunds
func (_m *FullNode) PaychGet(ctx context.Context, from address.Address, to address.Address, ensureFunds big.Int) (*api.ChannelInfo, error) {
	ret := _m.Called(ctx, from, to, ensureFunds)

	var r0 *api.ChannelInfo
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, address.Address, big.Int) *api.ChannelInfo); ok {
		r0 = rf(ctx, from, to, ensureFunds)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.ChannelInfo)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, address.Address, address.Address, big.Int) error); ok {
		r1 = rf(ctx, from, to, ensureFunds)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PaychList provides a mock function with given fields: _a0
func (_m *FullNode) PaychList(_a0 context.Context) ([]address.Address, error) {
	ret := _m.Called(_a0)

	var r0 []address.Address
	if rf, ok := ret.Get(0).(func(context.Context) []address.Address); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]address.Address)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PaychNewPayment provides a mock function with given fields: ctx, from, to, vouchers
func (_m *FullNode) PaychNewPayment(ctx context.Context, from address.Address, to address.Address, vouchers []api.VoucherSpec) (*api.PaymentInfo, error) {
	ret := _m.Called(ctx, from, to, vouchers)

	var r0 *api.PaymentInfo
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, address.Address, []api.VoucherSpec) *api.PaymentInfo); ok {
		r0 = rf(ctx, from, to, vouchers)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.PaymentInfo)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, address.Address, address.Address, []api.VoucherSpec) error); ok {
		r1 = rf(ctx, from, to, vouchers)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PaychStatus provides a mock function with given fields: _a0, _a1
func (_m *FullNode) PaychStatus(_a0 context.Context, _a1 address.Address) (*api.PaychStatus, error) {
	ret := _m.Called(_a0, _a1)

	var r0 *api.PaychStatus
	if rf, ok := ret.Get(0).(func(context.Context, address.Address) *api.PaychStatus); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.PaychStatus)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, address.Address) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PaychVoucherAdd provides a mock function with given fields: _a0, _a1, _a2, _a3, _a4
func (_m *FullNode) PaychVoucherAdd(_a0 context.Context, _a1 address.Address, _a2 *paych.SignedVoucher, _a3 []byte, _a4 big.Int) (big.Int, error) {
	ret := _m.Called(_a0, _a1, _a2, _a3, _a4)

	var r0 big.Int
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, *paych.SignedVoucher, []byte, big.Int) big.Int); ok {
		r0 = rf(_a0, _a1, _a2, _a3, _a4)
	} else {
		r0 = ret.Get(0).(big.Int)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, address.Address, *paych.SignedVoucher, []byte, big.Int) error); ok {
		r1 = rf(_a0, _a1, _a2, _a3, _a4)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PaychVoucherCheckSpendable provides a mock function with given fields: _a0, _a1, _a2, _a3, _a4
func (_m *FullNode) PaychVoucherCheckSpendable(_a0 context.Context, _a1 address.Address, _a2 *paych.SignedVoucher, _a3 []byte, _a4 []byte) (bool, error) {
	ret := _m.Called(_a0, _a1, _a2, _a3, _a4)

	var r0 bool
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, *paych.SignedVoucher, []byte, []byte) bool); ok {
		r0 = rf(_a0, _a1, _a2, _a3, _a4)
	} else {
		r0 = ret.Get(0).(bool)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, address.Address, *paych.SignedVoucher, []byte, []byte) error); ok {
		r1 = rf(_a0, _a1, _a2, _a3, _a4)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PaychVoucherCheckValid provides a mock function with given fields: _a0, _a1, _a2
func (_m *FullNode) PaychVoucherCheckValid(_a0 context.Context, _a1 address.Address, _a2 *paych.SignedVoucher) error {
	ret := _m.Called(_a0, _a1, _a2)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, *paych.SignedVoucher) error); ok {
		r0 = rf(_a0, _a1, _a2)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// PaychVoucherCreate provides a mock function with given fields: _a0, _a1, _a2, _a3
func (_m *FullNode) PaychVoucherCreate(_a0 context.Context, _a1 address.Address, _a2 big.Int, _a3 uint64) (*paych.SignedVoucher, error) {
	ret := _m.Called(_a0, _a1, _a2, _a3)

	var r0 *paych.SignedVoucher
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, big.Int, uint64) *paych.SignedVoucher); ok {
		r0 = rf(_a0, _a1, _a2, _a3)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*paych.SignedVoucher)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, address.Address, big.Int, uint64) error); ok {
		r1 = rf(_a0, _a1, _a2, _a3)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PaychVoucherList provides a mock function with given fields: _a0, _a1
func (_m *FullNode) PaychVoucherList(_a0 context.Context, _a1 address.Address) ([]*paych.SignedVoucher, error) {
	ret := _m.Called(_a0, _a1)

	var r0 []*paych.SignedVoucher
	if rf, ok := ret.Get(0).(func(context.Context, address.Address) []*paych.SignedVoucher); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*paych.SignedVoucher)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, address.Address) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PaychVoucherSubmit provides a mock function with given fields: _a0, _a1, _a2
func (_m *FullNode) PaychVoucherSubmit(_a0 context.Context, _a1 address.Address, _a2 *paych.SignedVoucher) (cid.Cid, error) {
	ret := _m.Called(_a0, _a1, _a2)

	var r0 cid.Cid
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, *paych.SignedVoucher) cid.Cid); ok {
		r0 = rf(_a0, _a1, _a2)
	} else {
		r0 = ret.Get(0).(cid.Cid)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, address.Address, *paych.SignedVoucher) error); ok {
		r1 = rf(_a0, _a1, _a2)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Shutdown provides a mock function with given fields: _a0
func (_m *FullNode) Shutdown(_a0 context.Context) error {
	ret := _m.Called(_a0)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context) error); ok {
		r0 = rf(_a0)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// StateAccountKey provides a mock function with given fields: _a0, _a1, _a2
func (_m *FullNode) StateAccountKey(_a0 context.Context, _a1 address.Address, _a2 types.TipSetKey) (address.Address, error) {
	ret := _m.Called(_a0, _a1, _a2)

	var r0 address.Address
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, types.TipSetKey) address.Address); ok {
		r0 = rf(_a0, _a1, _a2)
	} else {
		r0 = ret.Get(0).(address.Address)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, address.Address, types.TipSetKey) error); ok {
		r1 = rf(_a0, _a1, _a2)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StateAllMinerFaults provides a mock function with given fields: ctx, lookback, ts
func (_m *FullNode) StateAllMinerFaults(ctx context.Context, lookback abi.ChainEpoch, ts types.TipSetKey) ([]*api.Fault, error) {
	ret := _m.Called(ctx, lookback, ts)

	var r0 []*api.Fault
	if rf, ok := ret.Get(0).(func(context.Context, abi.ChainEpoch, types.TipSetKey) []*api.Fault); ok {
		r0 = rf(ctx, lookback, ts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*api.Fault)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, abi.ChainEpoch, types.TipSetKey) error); ok {
		r1 = rf(ctx, lookback, ts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StateCall provides a mock function with given fields: _a0, _a1, _a2
func (_m *FullNode) StateCall(_a0 context.Context, _a1 *types.Message, _a2 types.TipSetKey) (*api.InvocResult, error) {
	ret := _m.Called(_a0, _a1, _a2)

	var r0 *api.InvocResult
	if rf, ok := ret.Get(0).(func(context.Context, *types.Message, types.TipSetKey) *api.InvocResult); ok {
		r0 = rf(_a0, _a1, _a2)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.InvocResult)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *types.Message, types.TipSetKey) error); ok {
		r1 = rf(_a0, _a1, _a2)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StateChangedActors provides a mock function with given fields: _a0, _a1, _a2
func (_m *FullNode) StateChangedActors(_a0 context.Context, _a1 cid.Cid, _a2 cid.Cid) (map[string]types.Actor, error) {
	ret := _m.Called(_a0, _a1, _a2)

	var r0 map[string]types.Actor
	if rf, ok := ret.Get(0).(func(context.Context, cid.Cid, cid.Cid) map[string]types.Actor); ok {
		r0 = rf(_a0, _a1, _a2)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string]types.Actor)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, cid.Cid, cid.Cid) error); ok {
		r1 = rf(_a0, _a1, _a2)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StateCompute provides a mock function with given fields: _a0, _a1, _a2, _a3
func (_m *FullNode) StateCompute(_a0 context.Context, _a1 abi.ChainEpoch, _a2 []*types.Message, _a3 types.TipSetKey) (*api.ComputeStateOutput, error) {
	ret := _m.Called(_a0, _a1, _a2, _a3)

	var r0 *api.ComputeStateOutput
	if rf, ok := ret.Get(0).(func(context.Context, abi.ChainEpoch, []*types.Message, types.TipSetKey) *api.ComputeStateOutput); ok {
		r0 = rf(_a0, _a1, _a2, _a3)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.ComputeStateOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, abi.ChainEpoch, []*types.Message, types.TipSetKey) error); ok {
		r1 = rf(_a0, _a1, _a2, _a3)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StateGetActor provides a mock function with given fields: ctx, actor, tsk
func (_m *FullNode) StateGetActor(ctx context.Context, actor address.Address, tsk types.TipSetKey) (*types.Actor, error) {
	ret := _m.Called(ctx, actor, tsk)

	var r0 *types.Actor
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, types.TipSetKey) *types.Actor); ok {
		r0 = rf(ctx, actor, tsk)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Actor)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, address.Address, types.TipSetKey) error); ok {
		r1 = rf(ctx, actor, tsk)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StateGetReceipt provides a mock function with given fields: _a0, _a1, _a2
func (_m *FullNode) StateGetReceipt(_a0 context.Context, _a1 cid.Cid, _a2 types.TipSetKey) (*types.MessageReceipt, error) {
	ret := _m.Called(_a0, _a1, _a2)

	var r0 *types.MessageReceipt
	if rf, ok := ret.Get(0).(func(context.Context, cid.Cid, types.TipSetKey) *types.MessageReceipt); ok {
		r0 = rf(_a0, _a1, _a2)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.MessageReceipt)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, cid.Cid, types.TipSetKey) error); ok {
		r1 = rf(_a0, _a1, _a2)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StateListActors provides a mock function with given fields: _a0, _a1
func (_m *FullNode) StateListActors(_a0 context.Context, _a1 types.TipSetKey) ([]address.Address, error) {
	ret := _m.Called(_a0, _a1)

	var r0 []address.Address
	if rf, ok := ret.Get(0).(func(context.Context, types.TipSetKey) []address.Address); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]address.Address)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, types.TipSetKey) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StateListMessages provides a mock function with given fields: ctx, match, tsk, toht
func (_m *FullNode) StateListMessages(ctx context.Context, match *types.Message, tsk types.TipSetKey, toht abi.ChainEpoch) ([]cid.Cid, error) {
	ret := _m.Called(ctx, match, tsk, toht)

	var r0 []cid.Cid
	if rf, ok := ret.Get(0).(func(context.Context, *types.Message, types.TipSetKey, abi.ChainEpoch) []cid.Cid); ok {
		r0 = rf(ctx, match, tsk, toht)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]cid.Cid)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *types.Message, types.TipSetKey, abi.ChainEpoch) error); ok {
		r1 = rf(ctx, match, tsk, toht)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StateListMiners provides a mock function with given fields: _a0, _a1
func (_m *FullNode) StateListMiners(_a0 context.Context, _a1 types.TipSetKey) ([]address.Address, error) {
	ret := _m.Called(_a0, _a1)

	var r0 []address.Address
	if rf, ok := ret.Get(0).(func(context.Context, types.TipSetKey) []address.Address); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]address.Address)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, types.TipSetKey) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StateLookupID provides a mock function with given fields: _a0, _a1, _a2
func (_m *FullNode) StateLookupID(_a0 context.Context, _a1 address.Address, _a2 types.TipSetKey) (address.Address, error) {
	ret := _m.Called(_a0, _a1, _a2)

	var r0 address.Address
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, types.TipSetKey) address.Address); ok {
		r0 = rf(_a0, _a1, _a2)
	} else {
		r0 = ret.Get(0).(address.Address)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, address.Address, types.TipSetKey) error); ok {
		r1 = rf(_a0, _a1, _a2)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StateMarketBalance provides a mock function with given fields: _a0, _a1, _a2
func (_m *FullNode) StateMarketBalance(_a0 context.Context, _a1 address.Address, _a2 types.TipSetKey) (api.MarketBalance, error) {
	ret := _m.Called(_a0, _a1, _a2)

	var r0 api.MarketBalance
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, types.TipSetKey) api.MarketBalance); ok {
		r0 = rf(_a0, _a1, _a2)
	} else {
		r0 = ret.Get(0).(api.MarketBalance)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, address.Address, types.TipSetKey) error); ok {
		r1 = rf(_a0, _a1, _a2)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StateMarketDeals provides a mock function with given fields: _a0, _a1
func (_m *FullNode) StateMarketDeals(_a0 context.Context, _a1 types.TipSetKey) (map[string]api.MarketDeal, error) {
	ret := _m.Called(_a0, _a1)

	var r0 map[string]api.MarketDeal
	if rf, ok := ret.Get(0).(func(context.Context, types.TipSetKey) map[string]api.MarketDeal); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string]api.MarketDeal)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, types.TipSetKey) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StateMarketParticipants provides a mock function with given fields: _a0, _a1
func (_m *FullNode) StateMarketParticipants(_a0 context.Context, _a1 types.TipSetKey) (map[string]api.MarketBalance, error) {
	ret := _m.Called(_a0, _a1)

	var r0 map[string]api.MarketBalance
	if rf, ok := ret.Get(0).(func(context.Context, types.TipSetKey) map[string]api.MarketBalance); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string]api.MarketBalance)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, types.TipSetKey) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StateMarketStorageDeal provides a mock function with given fields: _a0, _a1, _a2
func (_m *FullNode) StateMarketStorageDeal(_a0 context.Context, _a1 abi.DealID, _a2 types.TipSetKey) (*api.MarketDeal, error) {
	ret := _m.Called(_a0, _a1, _a2)

	var r0 *api.MarketDeal
	if rf, ok := ret.Get(0).(func(context.Context, abi.DealID, types.TipSetKey) *api.MarketDeal); ok {
		r0 = rf(_a0, _a1, _a2)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.MarketDeal)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, abi.DealID, types.TipSetKey) error); ok {
		r1 = rf(_a0, _a1, _a2)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StateMinerAvailableBalance provides a mock function with given fields: _a0, _a1, _a2
func (_m *FullNode) StateMinerAvailableBalance(_a0 context.Context, _a1 address.Address, _a2 types.TipSetKey) (big.Int, error) {
	ret := _m.Called(_a0, _a1, _a2)

	var r0 big.Int
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, types.TipSetKey) big.Int); ok {
		r0 = rf(_a0, _a1, _a2)
	} else {
		r0 = ret.Get(0).(big.Int)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, address.Address, types.TipSetKey) error); ok {
		r1 = rf(_a0, _a1, _a2)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StateMinerDeadlines provides a mock function with given fields: _a0, _a1, _a2
func (_m *FullNode) StateMinerDeadlines(_a0 context.Context, _a1 address.Address, _a2 types.TipSetKey) (*miner.Deadlines, error) {
	ret := _m.Called(_a0, _a1, _a2)

	var r0 *miner.Deadlines
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, types.TipSetKey) *miner.Deadlines); ok {
		r0 = rf(_a0, _a1, _a2)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*miner.Deadlines)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, address.Address, types.TipSetKey) error); ok {
		r1 = rf(_a0, _a1, _a2)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StateMinerFaults provides a mock function with given fields: _a0, _a1, _a2
func (_m *FullNode) StateMinerFaults(_a0 context.Context, _a1 address.Address, _a2 types.TipSetKey) (*bitfield.BitField, error) {
	ret := _m.Called(_a0, _a1, _a2)

	var r0 *bitfield.BitField
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, types.TipSetKey) *bitfield.BitField); ok {
		r0 = rf(_a0, _a1, _a2)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bitfield.BitField)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, address.Address, types.TipSetKey) error); ok {
		r1 = rf(_a0, _a1, _a2)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StateMinerInfo provides a mock function with given fields: _a0, _a1, _a2
func (_m *FullNode) StateMinerInfo(_a0 context.Context, _a1 address.Address, _a2 types.TipSetKey) (api.MinerInfo, error) {
	ret := _m.Called(_a0, _a1, _a2)

	var r0 api.MinerInfo
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, types.TipSetKey) api.MinerInfo); ok {
		r0 = rf(_a0, _a1, _a2)
	} else {
		r0 = ret.Get(0).(api.MinerInfo)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, address.Address, types.TipSetKey) error); ok {
		r1 = rf(_a0, _a1, _a2)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StateMinerInitialPledgeCollateral provides a mock function with given fields: _a0, _a1, _a2, _a3
func (_m *FullNode) StateMinerInitialPledgeCollateral(_a0 context.Context, _a1 address.Address, _a2 abi.SectorNumber, _a3 types.TipSetKey) (big.Int, error) {
	ret := _m.Called(_a0, _a1, _a2, _a3)

	var r0 big.Int
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, abi.SectorNumber, types.TipSetKey) big.Int); ok {
		r0 = rf(_a0, _a1, _a2, _a3)
	} else {
		r0 = ret.Get(0).(big.Int)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, address.Address, abi.SectorNumber, types.TipSetKey) error); ok {
		r1 = rf(_a0, _a1, _a2, _a3)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StateMinerPower provides a mock function with given fields: _a0, _a1, _a2
func (_m *FullNode) StateMinerPower(_a0 context.Context, _a1 address.Address, _a2 types.TipSetKey) (*api.MinerPower, error) {
	ret := _m.Called(_a0, _a1, _a2)

	var r0 *api.MinerPower
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, types.TipSetKey) *api.MinerPower); ok {
		r0 = rf(_a0, _a1, _a2)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.MinerPower)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, address.Address, types.TipSetKey) error); ok {
		r1 = rf(_a0, _a1, _a2)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StateMinerProvingDeadline provides a mock function with given fields: _a0, _a1, _a2
func (_m *FullNode) StateMinerProvingDeadline(_a0 context.Context, _a1 address.Address, _a2 types.TipSetKey) (*miner.DeadlineInfo, error) {
	ret := _m.Called(_a0, _a1, _a2)

	var r0 *miner.DeadlineInfo
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, types.TipSetKey) *miner.DeadlineInfo); ok {
		r0 = rf(_a0, _a1, _a2)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*miner.DeadlineInfo)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, address.Address, types.TipSetKey) error); ok {
		r1 = rf(_a0, _a1, _a2)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StateMinerProvingSet provides a mock function with given fields: _a0, _a1, _a2
func (_m *FullNode) StateMinerProvingSet(_a0 context.Context, _a1 address.Address, _a2 types.TipSetKey) ([]*api.ChainSectorInfo, error) {
	ret := _m.Called(_a0, _a1, _a2)

	var r0 []*api.ChainSectorInfo
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, types.TipSetKey) []*api.ChainSectorInfo); ok {
		r0 = rf(_a0, _a1, _a2)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*api.ChainSectorInfo)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, address.Address, types.TipSetKey) error); ok {
		r1 = rf(_a0, _a1, _a2)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StateMinerRecoveries provides a mock function with given fields: _a0, _a1, _a2
func (_m *FullNode) StateMinerRecoveries(_a0 context.Context, _a1 address.Address, _a2 types.TipSetKey) (*bitfield.BitField, error) {
	ret := _m.Called(_a0, _a1, _a2)

	var r0 *bitfield.BitField
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, types.TipSetKey) *bitfield.BitField); ok {
		r0 = rf(_a0, _a1, _a2)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bitfield.BitField)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, address.Address, types.TipSetKey) error); ok {
		r1 = rf(_a0, _a1, _a2)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StateMinerSectorCount provides a mock function with given fields: _a0, _a1, _a2
func (_m *FullNode) StateMinerSectorCount(_a0 context.Context, _a1 address.Address, _a2 types.TipSetKey) (api.MinerSectors, error) {
	ret := _m.Called(_a0, _a1, _a2)

	var r0 api.MinerSectors
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, types.TipSetKey) api.MinerSectors); ok {
		r0 = rf(_a0, _a1, _a2)
	} else {
		r0 = ret.Get(0).(api.MinerSectors)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, address.Address, types.TipSetKey) error); ok {
		r1 = rf(_a0, _a1, _a2)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StateMinerSectors provides a mock function with given fields: _a0, _a1, _a2, _a3, _a4
func (_m *FullNode) StateMinerSectors(_a0 context.Context, _a1 address.Address, _a2 *bitfield.BitField, _a3 bool, _a4 types.TipSetKey) ([]*api.ChainSectorInfo, error) {
	ret := _m.Called(_a0, _a1, _a2, _a3, _a4)

	var r0 []*api.ChainSectorInfo
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, *bitfield.BitField, bool, types.TipSetKey) []*api.ChainSectorInfo); ok {
		r0 = rf(_a0, _a1, _a2, _a3, _a4)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*api.ChainSectorInfo)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, address.Address, *bitfield.BitField, bool, types.TipSetKey) error); ok {
		r1 = rf(_a0, _a1, _a2, _a3, _a4)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StateNetworkName provides a mock function with given fields: _a0
func (_m *FullNode) StateNetworkName(_a0 context.Context) (dtypes.NetworkName, error) {
	ret := _m.Called(_a0)

	var r0 dtypes.NetworkName
	if rf, ok := ret.Get(0).(func(context.Context) dtypes.NetworkName); ok {
		r0 = rf(_a0)
	} else {
		r0 = ret.Get(0).(dtypes.NetworkName)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StatePledgeCollateral provides a mock function with given fields: _a0, _a1
func (_m *FullNode) StatePledgeCollateral(_a0 context.Context, _a1 types.TipSetKey) (big.Int, error) {
	ret := _m.Called(_a0, _a1)

	var r0 big.Int
	if rf, ok := ret.Get(0).(func(context.Context, types.TipSetKey) big.Int); ok {
		r0 = rf(_a0, _a1)
	} else {
		r0 = ret.Get(0).(big.Int)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, types.TipSetKey) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StateReadState provides a mock function with given fields: ctx, act, tsk
func (_m *FullNode) StateReadState(ctx context.Context, act *types.Actor, tsk types.TipSetKey) (*api.ActorState, error) {
	ret := _m.Called(ctx, act, tsk)

	var r0 *api.ActorState
	if rf, ok := ret.Get(0).(func(context.Context, *types.Actor, types.TipSetKey) *api.ActorState); ok {
		r0 = rf(ctx, act, tsk)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.ActorState)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *types.Actor, types.TipSetKey) error); ok {
		r1 = rf(ctx, act, tsk)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StateReplay provides a mock function with given fields: _a0, _a1, _a2
func (_m *FullNode) StateReplay(_a0 context.Context, _a1 types.TipSetKey, _a2 cid.Cid) (*api.InvocResult, error) {
	ret := _m.Called(_a0, _a1, _a2)

	var r0 *api.InvocResult
	if rf, ok := ret.Get(0).(func(context.Context, types.TipSetKey, cid.Cid) *api.InvocResult); ok {
		r0 = rf(_a0, _a1, _a2)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.InvocResult)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, types.TipSetKey, cid.Cid) error); ok {
		r1 = rf(_a0, _a1, _a2)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StateSearchMsg provides a mock function with given fields: _a0, _a1
func (_m *FullNode) StateSearchMsg(_a0 context.Context, _a1 cid.Cid) (*api.MsgLookup, error) {
	ret := _m.Called(_a0, _a1)

	var r0 *api.MsgLookup
	if rf, ok := ret.Get(0).(func(context.Context, cid.Cid) *api.MsgLookup); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.MsgLookup)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, cid.Cid) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StateSectorGetInfo provides a mock function with given fields: _a0, _a1, _a2, _a3
func (_m *FullNode) StateSectorGetInfo(_a0 context.Context, _a1 address.Address, _a2 abi.SectorNumber, _a3 types.TipSetKey) (*miner.SectorOnChainInfo, error) {
	ret := _m.Called(_a0, _a1, _a2, _a3)

	var r0 *miner.SectorOnChainInfo
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, abi.SectorNumber, types.TipSetKey) *miner.SectorOnChainInfo); ok {
		r0 = rf(_a0, _a1, _a2, _a3)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*miner.SectorOnChainInfo)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, address.Address, abi.SectorNumber, types.TipSetKey) error); ok {
		r1 = rf(_a0, _a1, _a2, _a3)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StateSectorPreCommitInfo provides a mock function with given fields: _a0, _a1, _a2, _a3
func (_m *FullNode) StateSectorPreCommitInfo(_a0 context.Context, _a1 address.Address, _a2 abi.SectorNumber, _a3 types.TipSetKey) (miner.SectorPreCommitOnChainInfo, error) {
	ret := _m.Called(_a0, _a1, _a2, _a3)

	var r0 miner.SectorPreCommitOnChainInfo
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, abi.SectorNumber, types.TipSetKey) miner.SectorPreCommitOnChainInfo); ok {
		r0 = rf(_a0, _a1, _a2, _a3)
	} else {
		r0 = ret.Get(0).(miner.SectorPreCommitOnChainInfo)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, address.Address, abi.SectorNumber, types.TipSetKey) error); ok {
		r1 = rf(_a0, _a1, _a2, _a3)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StateWaitMsg provides a mock function with given fields: ctx, _a1, confidence
func (_m *FullNode) StateWaitMsg(ctx context.Context, _a1 cid.Cid, confidence uint64) (*api.MsgLookup, error) {
	ret := _m.Called(ctx, _a1, confidence)

	var r0 *api.MsgLookup
	if rf, ok := ret.Get(0).(func(context.Context, cid.Cid, uint64) *api.MsgLookup); ok {
		r0 = rf(ctx, _a1, confidence)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.MsgLookup)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, cid.Cid, uint64) error); ok {
		r1 = rf(ctx, _a1, confidence)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SyncCheckBad provides a mock function with given fields: ctx, bcid
func (_m *FullNode) SyncCheckBad(ctx context.Context, bcid cid.Cid) (string, error) {
	ret := _m.Called(ctx, bcid)

	var r0 string
	if rf, ok := ret.Get(0).(func(context.Context, cid.Cid) string); ok {
		r0 = rf(ctx, bcid)
	} else {
		r0 = ret.Get(0).(string)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, cid.Cid) error); ok {
		r1 = rf(ctx, bcid)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SyncIncomingBlocks provides a mock function with given fields: ctx
func (_m *FullNode) SyncIncomingBlocks(ctx context.Context) (<-chan *types.BlockHeader, error) {
	ret := _m.Called(ctx)

	var r0 <-chan *types.BlockHeader
	if rf, ok := ret.Get(0).(func(context.Context) <-chan *types.BlockHeader); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(<-chan *types.BlockHeader)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SyncMarkBad provides a mock function with given fields: ctx, bcid
func (_m *FullNode) SyncMarkBad(ctx context.Context, bcid cid.Cid) error {
	ret := _m.Called(ctx, bcid)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, cid.Cid) error); ok {
		r0 = rf(ctx, bcid)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SyncState provides a mock function with given fields: _a0
func (_m *FullNode) SyncState(_a0 context.Context) (*api.SyncState, error) {
	ret := _m.Called(_a0)

	var r0 *api.SyncState
	if rf, ok := ret.Get(0).(func(context.Context) *api.SyncState); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.SyncState)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SyncSubmitBlock provides a mock function with given fields: ctx, blk
func (_m *FullNode) SyncSubmitBlock(ctx context.Context, blk *types.BlockMsg) error {
	ret := _m.Called(ctx, blk)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *types.BlockMsg) error); ok {
		r0 = rf(ctx, blk)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Version provides a mock function with given fields: _a0
func (_m *FullNode) Version(_a0 context.Context) (api.Version, error) {
	ret := _m.Called(_a0)

	var r0 api.Version
	if rf, ok := ret.Get(0).(func(context.Context) api.Version); ok {
		r0 = rf(_a0)
	} else {
		r0 = ret.Get(0).(api.Version)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WalletBalance provides a mock function with given fields: _a0, _a1
func (_m *FullNode) WalletBalance(_a0 context.Context, _a1 address.Address) (big.Int, error) {
	ret := _m.Called(_a0, _a1)

	var r0 big.Int
	if rf, ok := ret.Get(0).(func(context.Context, address.Address) big.Int); ok {
		r0 = rf(_a0, _a1)
	} else {
		r0 = ret.Get(0).(big.Int)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, address.Address) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WalletDefaultAddress provides a mock function with given fields: _a0
func (_m *FullNode) WalletDefaultAddress(_a0 context.Context) (address.Address, error) {
	ret := _m.Called(_a0)

	var r0 address.Address
	if rf, ok := ret.Get(0).(func(context.Context) address.Address); ok {
		r0 = rf(_a0)
	} else {
		r0 = ret.Get(0).(address.Address)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WalletDelete provides a mock function with given fields: _a0, _a1
func (_m *FullNode) WalletDelete(_a0 context.Context, _a1 address.Address) error {
	ret := _m.Called(_a0, _a1)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, address.Address) error); ok {
		r0 = rf(_a0, _a1)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// WalletExport provides a mock function with given fields: _a0, _a1
func (_m *FullNode) WalletExport(_a0 context.Context, _a1 address.Address) (*types.KeyInfo, error) {
	ret := _m.Called(_a0, _a1)

	var r0 *types.KeyInfo
	if rf, ok := ret.Get(0).(func(context.Context, address.Address) *types.KeyInfo); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.KeyInfo)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, address.Address) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WalletHas provides a mock function with given fields: _a0, _a1
func (_m *FullNode) WalletHas(_a0 context.Context, _a1 address.Address) (bool, error) {
	ret := _m.Called(_a0, _a1)

	var r0 bool
	if rf, ok := ret.Get(0).(func(context.Context, address.Address) bool); ok {
		r0 = rf(_a0, _a1)
	} else {
		r0 = ret.Get(0).(bool)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, address.Address) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WalletImport provides a mock function with given fields: _a0, _a1
func (_m *FullNode) WalletImport(_a0 context.Context, _a1 *types.KeyInfo) (address.Address, error) {
	ret := _m.Called(_a0, _a1)

	var r0 address.Address
	if rf, ok := ret.Get(0).(func(context.Context, *types.KeyInfo) address.Address); ok {
		r0 = rf(_a0, _a1)
	} else {
		r0 = ret.Get(0).(address.Address)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *types.KeyInfo) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WalletList provides a mock function with given fields: _a0
func (_m *FullNode) WalletList(_a0 context.Context) ([]address.Address, error) {
	ret := _m.Called(_a0)

	var r0 []address.Address
	if rf, ok := ret.Get(0).(func(context.Context) []address.Address); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]address.Address)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WalletNew provides a mock function with given fields: _a0, _a1
func (_m *FullNode) WalletNew(_a0 context.Context, _a1 crypto.SigType) (address.Address, error) {
	ret := _m.Called(_a0, _a1)

	var r0 address.Address
	if rf, ok := ret.Get(0).(func(context.Context, crypto.SigType) address.Address); ok {
		r0 = rf(_a0, _a1)
	} else {
		r0 = ret.Get(0).(address.Address)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, crypto.SigType) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WalletSetDefault provides a mock function with given fields: _a0, _a1
func (_m *FullNode) WalletSetDefault(_a0 context.Context, _a1 address.Address) error {
	ret := _m.Called(_a0, _a1)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, address.Address) error); ok {
		r0 = rf(_a0, _a1)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// WalletSign provides a mock function with given fields: _a0, _a1, _a2
func (_m *FullNode) WalletSign(_a0 context.Context, _a1 address.Address, _a2 []byte) (*crypto.Signature, error) {
	ret := _m.Called(_a0, _a1, _a2)

	var r0 *crypto.Signature
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, []byte) *crypto.Signature); ok {
		r0 = rf(_a0, _a1, _a2)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*crypto.Signature)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, address.Address, []byte) error); ok {
		r1 = rf(_a0, _a1, _a2)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WalletSignMessage provides a mock function with given fields: _a0, _a1, _a2
func (_m *FullNode) WalletSignMessage(_a0 context.Context, _a1 address.Address, _a2 *types.Message) (*types.SignedMessage, error) {
	ret := _m.Called(_a0, _a1, _a2)

	var r0 *types.SignedMessage
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, *types.Message) *types.SignedMessage); ok {
		r0 = rf(_a0, _a1, _a2)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.SignedMessage)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, address.Address, *types.Message) error); ok {
		r1 = rf(_a0, _a1, _a2)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WalletVerify provides a mock function with given fields: _a0, _a1, _a2, _a3
func (_m *FullNode) WalletVerify(_a0 context.Context, _a1 address.Address, _a2 []byte, _a3 *crypto.Signature) bool {
	ret := _m.Called(_a0, _a1, _a2, _a3)

	var r0 bool
	if rf, ok := ret.Get(0).(func(context.Context, address.Address, []byte, *crypto.Signature) bool); ok {
		r0 = rf(_a0, _a1, _a2, _a3)
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}
